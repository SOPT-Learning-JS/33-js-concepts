# 자바 스크립트 엔진

JavaScript 엔진의 예는 Google의 V8 엔진이다. V8 엔진은 NodeJS 에서도 사용된다. 

![image](https://user-images.githubusercontent.com/45676906/97333418-e765e680-18be-11eb-8e1b-1b1fff3e830e.png)

엔진은 두 가지 주요 구성 요소로 구성된다.

- `메모리 힙` : 메모리 할당이 발생하는 곳이다.
- `호출 스택` : 코드가 실행될 때 스택 프레임이 있는 곳이다. 

# 호출 스택이란?

`호출 스택`은 기본적으로 우리가 프로그램에서 어디에 있는지 기록하는 데이터 구조이다. 함수에 들어가면 스택 맨 위에 쌓인다. 함수가 종료되면 스택의 맨 위에서 꺼내진다.

<br>

JavaScript는 `단일 스레드 프로그래밍 언어`이므로 `단일 호출 스택`이 있다. 따라서 한 번에 한 가지만 수행 할 수 있다. 이것은 콜 스택이 `동기식` 이라는 것을 의미한다. (호출 스택에 대한 이해는 `비동기` 프로그래밍에 필수적이다.)

<br>


```javascript
function foo(b) {
  var a = 5;
  return a * b + 10;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
} 

console.log(bar(6));
```

위의 코드가 어떤 순서로 실행될지 머리속으로 먼저 생각해보자. 


![image](https://miro.medium.com/max/1200/1*E3zTWtEOiDWw7d0n7Vp-mA.gif)

위의 코드의 실행과정을 생각해보면 `스택`과 비슷하다는 것을 알 수 있다. 그리고 위의 단순한 코드를 해석하는데는 크게 무리는 없겠지만 JavaScript 언어를 이해하는 데 가장 중요하고 근본적인 개념은 `실행 컨텍스트`를 이해하는 것이기 때문에 아래의 내용을 보면서 정확히 개념을 알고 넘어가자. 


<br>

# JavaScript 실행 컨텍스트

JavaScript 엔진이 코드를 실행할 때 생성되는 첫 번째 실행 컨텍스트를 `전역 실행 컨텍스트`라고 한다. `실행 컨텍스트`에 대해 자세히 알고 싶다면 [여기](https://github.com/wjdrbs96/Today-I-Learn/blob/master/JavaScript/Execution_Context.md)에서 확인하자. 

![image](https://user-images.githubusercontent.com/45676906/97339244-afae6d00-18c5-11eb-9b00-b771943b1fe5.png)

가장 처음에 브라우저가 스크립트를 로딩해서 실행하는 순간 `window`와 `this` 두 가지로 구성된 `전역 실행 컨텍스트`가 생긴다.(정확히 말하면 `scopeChain`도 존재한다.)

<br>

이번에는 프로그램에 코드를 추가하면서 좀 더 자세히 알아보자.

![image](https://user-images.githubusercontent.com/45676906/97339836-67dc1580-18c6-11eb-8ca6-2fcd113c6215.png)

<br>

![image](https://user-images.githubusercontent.com/45676906/97339896-77f3f500-18c6-11eb-998d-81e801af0bad.png)

위의 그림의 차이점은 무엇일까? `실행 컨텍스트`는 두 개의 별도의 단계를 가진다. `Creation`단계와 `Execution`단계를 가진다. 

<br>

전역 `Creation`단계에서 JavaScript 엔진은 

- 전역 객체를 만든다. 
- 'this'라는 객체를 만든다.
- 변수와 함수를 위한 메모리 공간을 설정한다. 
- 함수 선언을 메모리에 배치하는 동안 변수 선언에 기본값 `undefined`를 할당한다. 

<br>

`Creation`단계 동안 `window` 및 `this`가 생성되는 동안 변수 선언(`name`, `handle`)에는 기본 값이 할당 되어 `undefined`가 되고 함수 선언한 `getUser()`는 메모리에 올라간다. 
그리고 `Execution` 단계에 들어가면 JavaScript 엔진이 코드를 한 줄씩 실행하기 시작하고 이미 메모리에 있는 변수에 실제 값을 할당한다. 

<br>

```javascript
console.log('name: ', name);
console.log('handle: ', handle);
console.log('getUser :', getUser);

var name = 'Tyler'
var handle = '@tylermcginnis'

function getUser () {
  return {
    name: name,
    handle: handle
  }
}
```

위의 코드는 어떤 것이 출력이 될까? 코드를 실행해보면 자바스크립트 엔진이 코드를 한줄 한줄씩 해석할 것이다.
그러면 이전에 이미 `Creation` 단계가 수행이 되었을 것이고, 이 말은 변수에 기본값 `undefined`를 할당한 상태하고 `getUser()`함수는 메모리에 올라가 있는 상태이다. 

<br>

위와 같이 `Creation`단계에 변수를 선언하고 default value인 `undefined`로 변수에 할당하는 과정을 `Hosting`이라고 한다. 

<br>

지금까지는`전역 컨텍스트(Global Execution)`이고, 그 외에 알아야 할 실행 컨텍스트는 `함수 실행 컨텍스트`라고 한다.

<br>

여기서 핵심은 `실행 컨텍스트`가 생성되는 유일한 시간은 JavaScript 엔진이 처음 코드 해석을 시작할 때(Global Execution Context)이다. 그리고 `함수 실행 컨텍스트`은 함수가 호출될 때마다 생성된다.

<br>

### 다른 코드의 예시를 보면서 좀 더 알아보자. 

```javascript
function multiply(x, y) { 
    return x * y; 
}

function printSquare(x) { 
    var s = multiply(x, x); 
    console.log(s); 
}

printSquare(5);
```

![image](https://user-images.githubusercontent.com/45676906/97334299-f13c1980-18bf-11eb-90e2-e44e18afe14f.png)

코드의 실행 순서는 위의 그림과 같다. 위에서 설명했던 것 처럼 함수가 호출되는 순서대로 `호출 스택`에 하나씩 쌓이는 것을 볼 수 있다. 

<br>

그리고 여기서 호출 스택의 각 항목을 `스택 프레임`이라고 한다. 
2개의 예시를 보면서 `호출 스택`에 대한 개념이 어느정도 생겼을 것이다. 

<br>

그리고 아래의 코드는 예외가 발생하는 코드이다. 

```javascript
function foo() { 
  throw new Error('에러가 발생했습니다'); 
}

function bar() { 
  foo(); 
}

function start() { 
  bar(); 
}

start();
```

위의 코드를 실행하면 아래와 같은 결과를 볼 수 있다.

![스크린샷 2020-10-28 오전 1 57 51](https://user-images.githubusercontent.com/45676906/97335256-fd74a680-18c0-11eb-972d-fff819389fb8.png)

위와 같이 Error 가 던져진 이후의 위의 로그를 보면 `콜스택 (Call Stack)`을 확인할 수 있다.

<br>

## 스택 오버플로우

그리고 다음과 같은 에러를 본 적이 있을 것이다. 

```
Uncaught RangeError: Maximum call stack size exceeded
```

`호출 스택`이 가득 찼을 때 발생하는 에러이다. 재귀함수같이 함수 안에서 계속 다른 함수를 호출하다보면 저기 스택이 가득 차다못해 터져버린다. 그래서 발생하는 에러이다. 

```javascript
function foo() { 
    foo(); 
}

foo();
```

![image](https://user-images.githubusercontent.com/45676906/97336440-5a249100-18c2-11eb-98f8-ebf404725376.png)


<br>

## 단일 호출 스택의 문제점

단일 스레드에서 코드를 실행하는 것은 멀티 스레드 환경에서 발생하는 복잡한 시나리오(예: deadlocks)를 고려할 필요가 없으므로 매우 쉽다. 그러나 단일 스레드에서 실행하는 것도 상당히 제한적이다. 자바스크립트에서는 하나의 호출 스택만 있기 때문에, 하나의 함수 처리가 엄청 느려서 다른 함수 실행에 지장을 줄 때는 어떻게 해야 할까?

<br>

예를 들어, 브라우저에서 복잡한 이미지 처리를 한다고 생각해보자. 앞서 배운 호출 스택의 동작 방식을 생각 해볼 때, 이미지 처리 작업 스택을 차지하고 있으면 자바스크립트는 후속 작업들을 처리할 수 없다. 단일 스레드, 단일 호출 스택이기 때문이다.

<br>

문제는 이것뿐만이 아니다. 브라우저가 호출 스택에서 많은 작업을 처리하기 시작하면 꽤 오랜 시간 동안 응답을 멈출 수 있다. 대부분의 브라우저는 이 상황에서 웹 페이지를 종료할지 여부를 묻는 오류 메시지를 표시한다. 그렇다면 해결 방법은 무엇일까?

![image](https://user-images.githubusercontent.com/45676906/97470954-83f5ba80-198b-11eb-880f-d6621c9c3263.png)

<br>

## 비동기 콜백(Asynchronous callbacks)

가장 쉬운 해결책은 `비동기 콜백`을 사용하는 것이다. 즉, 우리의 코드 일부를 실행하고 나중에 실행될 콜백(함수)를 제공한다. 비동기 콜백은 즉시가 아닌, 특수한 시점에 실행되므로 console.log와 같은 동기 함수와는 다르게 스택 안에 바로 push 될 필요가 없습니다. 그런데 스택이 아니라면 이 콜백 함수들은 누가 관리하는 것일까?

<br>

## 이벤트 큐(Event Queue)와 비동기 콜백의 처리 과정

자바스크립트 실행환경(Runtime)은 `이벤트 큐(Event Queue)`를 가지고 있습니다. 이는 처리할 메시지 목록과 실행할 콜백 함수 들의 리스트이다.

![image](https://user-images.githubusercontent.com/45676906/97471275-e64ebb00-198b-11eb-8950-9a89328fa84d.png)

지금은 이런 것이 있다는 정도만 알고 나중에 `이벤트 루프` 개념을 배울 때 같이 보면서 개념을 익히며 좋을 것 같다. 

<br>

# Reference

- [https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)

- [https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec](https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec)

- [https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/](https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/)

- [https://new93helloworld.tistory.com/358](https://new93helloworld.tistory.com/358)