<div align="center">

  <img height="170" width="170" src="https://img.icons8.com/color/344/javascript.png">

  # 모든 자바스크립트 개발자가 알아야 하는 33가지 개념 정리

</div>

## 목차 🥇

1. [자바스크립트 엔진](#JS-Engine)
2. [스택(Stack)이란?](#stack-is)
3. [자바스크립트에서의 콜스택](#callStack-is)
4. [콜스택 오버플로우](#callStack-overflow)
5. [콜스택의 문제점](#callStack-problem)
6. [힙](#heap)
7. [큐](#queue)

---

# 들어가며 

## 브라우저는 어떻게 동작하는가? <a name="JS-Engine"></a>

### 브라우저의 역할

사용자가 선택한 자원(URL)을 서버에 요청하고 받아 화면에 표시한다. 조금 더 풀어서 이야기하면, 주소창에 주소를 입력한 후, 엔터를 치면 브라우저가 해당 주소로 요청을 보낸다. 이때, 요청을 받은 곳, 즉, 서버에서 응답을 보내준다. 브라우저는 요청에 대한 결과(응답)를 화면에 그린다. 

<img src = "https://user-images.githubusercontent.com/59385491/97271699-3a667c00-1874-11eb-9e19-ef9f4d36924a.png" width="600px">

---

### 브라우저의 구조

<img src = "https://user-images.githubusercontent.com/59385491/97271824-6a158400-1874-11eb-884a-b7dff54c7ac0.png" width="500px">

- UI : 주소창, 즐겨찾기 등 사용자가 조작 가능한 영역
- 브라우저 엔진 : UI와 렌더링 엔진 동작 제어
- **렌더링 엔진** : 요청한 결과(응답)를 화면에 표시
- 네트워킹 : HTTP 요청과 같은 네트워크 호출을 위해서 필요한 부분
- UI 백엔드 : OS 사용자 인터페이스 방법을 활용하여, 기본적인 위젯(콤보 박스 등)을 그림
- **JS 엔진/인터프리터** : 자바스크립트를 해석하고 실행
- 데이터 저장소 : Local Storage, Indexed DB, 쿠키 등 브라우저 메모리를 활용하여 저장하는 영역

---

<details><summary><b>브라우저의 렌더링 과정을 알고 싶다면</b></summary>

<p>

<br></br>

### 브라우저의 렌더링 과정

#### 브라우저의 렌더링 엔진 - critical rendering path

브라우저의 렌더링 엔진은 서버로부터 받은 내용을 브라우저에 표시하는 역할을 한다.
다시 말해서, 서버로부터 받은 내용(HTML, CSS, Javascript.. 등의 파일)을 변환해서 화면에 픽셀 단위로 나타내는 과정이다.

> 1. DOM(Document Object Model) 생성
> 2. CSSOM(CSS Object Model) 생성
> 3. Render Tree(DOM + CSSOM) 생성
> 4. Render Tree 배치 
> 5. Render Tree 그리기

위와 같이 다섯 단계를 거친다. 2번 CSSOM 생성 과정을 따로 분리하지 않고, 네 단계로 표현하기도 한다.

<br></br>

#### 렌더링 엔진 flow chart

Webkit엔진에서는 이 과정을 각각 어떻게 처리하는 지 알아보자.

<img src = "https://user-images.githubusercontent.com/59385491/97272913-eb214b00-1875-11eb-926e-569bc0a6093e.png" width="700px">

<br></br>

1. DOM(Document Object Model) 생성

  - 다음 네 단계를 거쳐서, 트리 구조 모양의 DOM이 생성된다.

    1. Conversion(변환) : HTML의 raw bytes(원시 바이트)형태로 서버에서 받아온다. 해당 파일의 인코딩(ex: UTF-8)에 따라 문자로 변환한다.
    2. Tokenizing(토큰화) : 브라우저가 변환된 문자열을 HTML5 표준에 따라 고유 토큰으로 변환한다.
    3. Lexing(렉싱) : 이 토큰들은 다시 각각의 특성과 규칙을 정의한 object(객체) "노드"로 변환된다.
    4. DOM 생성 : HTML 마크업이 여러 태그 간의 관계를 나타내기 때문에 DOM은 트리 구조를 가진다. 따라서, DOM에 포함된 노드 또한 서로 관계를 가지게 된다. 다시 말해서, 노드의 상대적인 관계를 이용하면, 하나의 노드를 기준으로 모든 노드에 접근할 수 있다.
  
  - DOM 트리는 문서 마크업의 속성과 관계를 포함하지만, 렌더링될 때 표시되는 모습에 대해서는 CSSOM이 관여한다.

<br></br>

2. CSSOM(CSS Object Model) 생성
  - 1. 에서 DOM을 생성할 때 거쳤던 과정을 그대로 CSS에 반복한다. 그 결과로 브라우저가 이해하고 처리할 수 있는 형식(Style Rules)으로 변환된다.
  - CSSOM 역시 트리 구조를 가지는데, 그 이유는, '하향식'으로 규칙을 적용하기 때문이다. 루트(body)부터 시작해서, 트리를 만들어 가는 방식이다. 모든 요소의 최종 스타일을 확정할 때 브라우저는 해당 노드에 적용 가능한 가장 일반적인 규칙으로 시작한 후에 더욱 구체적인 규칙을 적용한다.

<br></br>

3. Render Tree(DOM + CSSOM) 생성 - Attachment
   - DOM 트리의 루트(HTML)에서 시작해서, 페이지에 표시되는 각각의 노드에 일치하는 CSSOM 규칙을 찾아 붙인다.
   - 이때, 렌더링 트리에는 페이지를 렌더링하는 데 필요한 가시적인 노드만 포함된다. 따라서, 메타 태그나 스크립트 태그 같은 노드나 `display : none`으로 스타일이 지정된 노드는 제외된다. 그러나, `visibility : hidden` 스타일이 적용된 노드는 보이지는 않지만 공간을 차지하므로, 렌더링 트리에 포함된다.
   - 이 렌더링 트리가 화면에서 최종적으로 그리는 내용이 된다.

<br></br>

4. Render Tree 배치 - Layout
   - 지금까지의 과정을 요약하면, 브라우저가 화면에 표시할 노드와 해당 노드의 스타일을 계산하면서, 하나의 그룹으로 묶어서 렌더링 트리를 만든 것이다.
   - 레이아웃은 브라우저가 화면에 그리기 전에, 이 노드들을 정확한 위치와 크기로 나타내기 위해서 계산하는 과정이다. 이때, 모든 상대적인 값(예:%단위)은 절대적인 값(예:px단위)로 변환된다.

<br></br>

5. Render Tree 그리고 - Painting
   - 렌더링 트리의 각 노드를 화면의 픽셀로 나타내는 작업이다.

</p>
</details>


---

### 브라우저 동작 원리

브라우저는 크게 **렌더링 엔진, 자바스크립트 엔진**으로 나뉜다.

브라우저는 사용자가 참고하고자 하는 페이지를 서버에게 요청 후 그에 대한 응답을 화면에 보여주는 일을 한다.

  - **렌더링 엔진**
  
    서버로부터 받은 HTML, CSS은 렌더링 엔진의 HTML 파서, CSS 파서에 의해 DOM, CSSOM 트리가 만들어지고 렌더 트리로 결합된다. 렌더 트리를 기반으로 브라우저는 웹페이지를 표시한다. 

  - **자바스크립트 엔진**
  
    자바스크립트 처리는 자바스크립트 엔진이 하며 JS로 작성한 코드를 해석하고 실행하는 인터프리터이다. 
    렌더링 엔진의 HTML 파서가 DOM 생성 프로세스를 하던 중 스트립트 태그를 만나면, 자바스크립트 코드를 실행시키기 위해 자바스크립트 엔진에게 제어권한을 넘겨 주게 된다.
    DOM 트리가 다 형성되지 않았는데 자바스크립트에서 해당 DOM을 조작하려고 하면 문제가 발생하기 때문에 `<script>`태그는 HTML의 body 태그 제일 아래에 놓는 것이 좋다.
    
    자바스크립트 엔진은 표준적인 **인터프리터**로 구현될 수도 있고 자바스크립트 코드를 바이트 코드로 컴파일하는 **저스트인타임(just-in-time) 컴파일러**로 구현할 수 있다.
    V8의 경우, 웹 브라우저 내부에서 Javascript 수행속도 개선을 위해 처음 고안되었다. 속도 개선을 위해 인터프리터를 사용하는 대신 Javascript 코드를 머신코드로 번역하는 JIT 컴파일러로 구현되었다.

---

<details><summary><b>외부의 자바스크립트 파일을 불러오는 경우는?</b></summary>

<p>

외부 자바스크립트 파일의 경우 브라우저가 일시 중지하고 디스크, 캐시 또는 원격 서버에서 스크립트를 가져올 때까지 기다려야 한다.
이로 인해 주요 렌더링 경로에 수십 ~ 수천 밀리초의 지연이 추가로 발생할 수 있다.

</p>
</details>

---

### 자바스크립트 엔진

자바스크립트는 싱글 스레드 언어로 한번에 하나의 태스크만 처리할 수 있다. 구글에서 개발한 V8를 비롯해 대부분의 자바스크립트 엔진은 크게 세 영역으로 나뉜다.

- Call Stack
- Task Queue(Event Queue)
- Heap


<br> </br>

# 콜스택(Call Stack)  

## 스택(Stack)이란? <a name="stack-is"></a>  

스택(Stack)은 후입선출(**L**ast **I**n **F**irst **O**ut, **LIFO**)을 기본으로 하는 자료구조다.

기본적인 보통 연산은 pop, push, peek, is_empty가 존재한다.

- pop : 스택의 출력 연산
- push : 스택의 입력 연산
- peek : 스택의 가장 상단의 데이터를 확인하는 연산
- is_empty : 스택이 비어있는지 확인하는 연산

<details><summary><b>스택(Stack)의 사용 사례</b></summary>

<p>

- 콜스택 (함수의 재귀호출)
- 웹 브라우저 방문기록
- 실행 취소 (undo)
- 괄호 검사
- 후위 표기법 계산

</p>
</details>

<br></br>

## 자바스크립트에서의 콜스택 <a name="callStack-is"></a>

자바스크립트는 **하나의 스레드**로 단 **1개의 동시성**만 다루는 언어다.

이것은 자바스크립트가 한 번에 1개의 작업만 다룰 수 있다는 뜻이다.

자바스크립트는 **힙, 큐**와 함께 구성하는 **단일 콜스택**을 갖는다.

<br></br>

## 콜스택이란?

자바스크립트 엔진이 구동되면서 실행 중인 **코드를 추적**하는 공간이 **콜스택**이다.

함수( `function` )의 호출( `call` )을 기록하는 스택( stack )자료구조다.

<br></br>

### 코드로 이해하기

아래의 간단한 코드를 이용해  Call Stack 을 설명해보려한다.

```jsx
function foo() {
  console.log('function foo is called')
  throw new Error('oops!')
}

function bar() {
  console.log('function bar is called')
  foo()
}

function baz() {
  console.log('function baz is called')
  bar()
}

baz()
```

아래와 같이  foo , bar , baz 라는 3개의 함수를 작성했다. 

3개의 함수는 아래와 같은 역할을 한다.

- baz 함수 : bar 함수를 호출 ( `call` )
- bar 함수 : foo 함수를 호출 ( `call` )
- foo 함수 : Error 를 던짐 ( `throw` )

<br></br>

### 이미지로 이해하기

1.  baz 함수 호출

<img src = "https://user-images.githubusercontent.com/59385491/97168759-57e00b00-17cc-11eb-97fe-dcbe98b4577b.png" width="400px">

baz 함수가 호출되고 콜스택에 baz 함수가 push 된다.

2.  bar 함수 호출

<img src = "https://user-images.githubusercontent.com/59385491/97168805-68908100-17cc-11eb-97be-7f37ddd6ad1b.png" width="400px">

bar 함수가 호출되고 콜스택에 bar 함수가 push 된다.

3.  foo 함수 호출

<img src = "https://user-images.githubusercontent.com/59385491/97168827-71815280-17cc-11eb-89a6-858212cb7a16.png" width="400px">

foo 함수가 호출되고 콜스택에 foo 함수가 push 된다.

4. 최종 콜스택

<img src = "https://user-images.githubusercontent.com/59385491/97168868-81993200-17cc-11eb-8373-009e64596f2d.png" width="400px">


모든 콜스택이 push 되고 문제가 없는 경우 상단에 존재하는 함수부터
하나씩 pop 되게 되어 콜스택이 비어 있게 되면 해당 프로그램이 종료되는 것이다.
위의 경우 가장 상단에 있는 foo 에서 오류가 발생해 프로그램이 비정상 종료된다.

<br></br>

### 콘솔로 이해하기

작성한 자바스크립트 파일을 실행시켜 봤다.

![5](https://user-images.githubusercontent.com/59385491/97168901-8cec5d80-17cc-11eb-8f55-f170011ab405.png)

baz , bar , foo 함수가 순서대로 호출되는 것을 확인할 수 있다.
Error 가 던져진 이후의 아래의 로그를 보면 콜스택 ( `Call Stack` )을 확인할 수 있다.

![6](https://user-images.githubusercontent.com/59385491/97168926-970e5c00-17cc-11eb-801c-5df51f0683d2.png)


에러가 발생한 이후의 로그를 확인해보면 위의 콜스택 ( Call Stack )이미지와 같이
foo , bar , baz 순서로 쌓여있는 것을 확인할 수 있다. 

<br></br>

### 콜스택 오버플로우 <a name="callStack-overflow"></a>

아래와 같이  overflow 함수를 재귀호출하는 코드를 작성해보았다.

```jsx
function overflow() {
  overflow()
}

overflow()
```

실행 결과는 아래의 이미지와 같다.

![7](https://user-images.githubusercontent.com/59385491/97168951-9fff2d80-17cc-11eb-8366-bf72b5188ff4.png)

**Maximum call stack size exceeded**와 같이 콜스택 사이즈가 초과되었다는 오류를 볼 수 있다.

<img src = "https://user-images.githubusercontent.com/59385491/97168984-a9889580-17cc-11eb-9890-5a4be90ad009.png" width="400px">


콜스택의 사이즈를 초과하면 더 이상 함수를 실행할 수 없고 오류가 발생하고 종료된다.

<br></br>


## 콜스택의 문제점 <a name="callStack-problem"></a>

단일 콜스택이기 때문에, 하나의 함수가 엄청 느려서 다른 함수 실행에 지장을 줄 때는 어떻게 해야 할까?
이 때 비동기 콜백(Asynchronous callbacks)을 사용하면 된다.

이런 콜백함수는 누가 관리하는가? 

메시지 큐(Queue)와 이벤트 루프(Event Loop)가 관리한다.

메시지 큐는 이벤트 발생 후 **콜백 함수**들이 기다리는 공간이다. **이벤트 루프**가 콜스택에 전달한다.
이벤트 루프는 콜백 큐의 콜백함수를 콜 스택에 전달한다. **단, 콜 스택이 비어있을때만 가져온다.**

 
이는 **[메시지 큐와 이벤트 루프]()**를 배울 때 자세하게 배우면 되겠다.

<br></br>

---

## 힙 <a name="heap"></a>

자바스크립트 엔진이 구동되면서 변수, 함수 같은 정보를 저장하는 곳이 **메모리 힙(Memory Heap)**이다.
즉, 동적으로 만들어진 객체(인스턴스)가 메모리에 할당되는 곳이다.


```jsx
let n = 123
let s = 'string'

let o = {
  a: 1,
  b: null,
}

let a = [1, null, 'string']

function f(a) {
  return a + 2
}
```

위와 같이 자바스크립트 코드에서 변수, 함수를 선언하게 되면 힙에 저장되는 것이다.

<br></br>
---

## 큐 <a name="queue"></a>


큐는 **선입선출**(**F**irst **I**n **F**irst **O**ut, **FIFO**)의 특징을 갖는 자료구조다.
자바스크립트의 런타임 환경의 **이벤트 큐**는 처리할 **메시지 목록**과 **실행할 콜백 함수**들을 갖는다.
setTimeOut 과 같은 비동기 함수는 Web API 를 호출하며 Web API 는 **콜백 함수**를 큐에 삽입한다.

```jsx
setTimeOut(function() {
  console.log('First Log')
}, 0)

console.log('Second Log')
```

자바스크립트의 이벤트 큐와 이벤트 루프를 잘 모르고 위의 코드를 실행시켰다면

코드의 실행결과가  First Log , Second Log 순서대로 출력되는 것을 기대했을 것이다.

<img src = "https://user-images.githubusercontent.com/59385491/97169047-c0c78300-17cc-11eb-90ba-91338e2460d4.png" width="500px">

코드를 실행시켜보면 위와 같이  Second Log 가 먼저 출력되게 된다.


![10](https://user-images.githubusercontent.com/59385491/97169061-c6bd6400-17cc-11eb-8339-d565172115aa.png)

setTimeOut 함수의 2번째 인자에 0ms를 주었다고 바로 실행되는 것이 아니다.
Web API 에 의해 호출된  First Log 가 출력되는 **콜백 함수**는 이벤트 큐에 삽입된다.
이것은 0ms뒤에 함수를 실행시키라는 의미가 아니라 **이벤트 큐에 삽입하라는 의미**다.

![11](https://user-images.githubusercontent.com/59385491/97169090-d046cc00-17cc-11eb-8de5-922c8e7e7101.png)

따라서  console.log("Second Log"); 가 **콜스택**에 삽입 된다.

![12](https://user-images.githubusercontent.com/59385491/97169111-d63cad00-17cc-11eb-81bc-fd1109b234f2.png)

**콜스택**에 있는 모든 함수 실행이 끝나고 삭제되어 **콜스택**이 비어있게 된다.

![13](https://user-images.githubusercontent.com/59385491/97169126-db99f780-17cc-11eb-84ee-8173b6770f71.png)

즉 스택이 비어있는 시점에  setTimeOut 함수의 콜백함수로 들어간 console.log("First Log") 가 큐에서 나오며 실행되는 것이다.

출처 : [Minsu's Dev Log](https://alstn2468.github.io/Javascript/2020-02-28-callstack/)

출처 : [imacoolgirlyo.log](https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-Event-Loop-Event-Queue-Call-Stack)

출처 : [장한보람블로그](https://janghanboram.github.io/2018/06/06/browser-rendering/)

출처 : [휴먼스케이프 기술 블로그](https://medium.com/humanscape-tech/javascript-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC%EB%A5%BC-%EC%82%B4%ED%8E%B4%EB%B4%85%EC%8B%9C%EB%8B%A4-aef465c9c43)


---










